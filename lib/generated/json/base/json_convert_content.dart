// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
import 'package:cashier/model/user_entity.dart';
import 'package:cashier/generated/json/user_entity_helper.dart';
import 'package:cashier/model/pay_channel_entity.dart';
import 'package:cashier/generated/json/pay_channel_entity_helper.dart';

class JsonConvert<T> {
  T fromJson(Map<String, dynamic> json) {
    return _getFromJson<T>(runtimeType, this, json);
  }

  Map<String, dynamic> toJson() {
    return _getToJson<T>(runtimeType, this);
  }

  static _getFromJson<T>(Type type, data, json) {
    switch (type) {
      case UserEntity:
        return userEntityFromJson(data as UserEntity, json) as T;
      case UserData:
        return userDataFromJson(data as UserData, json) as T;
      case UserDataBanner:
        return userDataBannerFromJson(data as UserDataBanner, json) as T;
      case UserDataUserInfo:
        return userDataUserInfoFromJson(data as UserDataUserInfo, json) as T;
      case PayChannelEntity:
        return payChannelEntityFromJson(data as PayChannelEntity, json) as T;
      case PayChannelData:
        return payChannelDataFromJson(data as PayChannelData, json) as T;
      case PayChannelDataPayChannel:
        return payChannelDataPayChannelFromJson(
            data as PayChannelDataPayChannel, json) as T;
    }
    return data as T;
  }

  static _getToJson<T>(Type type, data) {
    switch (type) {
      case UserEntity:
        return userEntityToJson(data as UserEntity);
      case UserData:
        return userDataToJson(data as UserData);
      case UserDataBanner:
        return userDataBannerToJson(data as UserDataBanner);
      case UserDataUserInfo:
        return userDataUserInfoToJson(data as UserDataUserInfo);
      case PayChannelEntity:
        return payChannelEntityToJson(data as PayChannelEntity);
      case PayChannelData:
        return payChannelDataToJson(data as PayChannelData);
      case PayChannelDataPayChannel:
        return payChannelDataPayChannelToJson(data as PayChannelDataPayChannel);
    }
    return data as T;
  }

  //Go back to a single instance by type
  static _fromJsonSingle(String type, json) {
    switch (type) {
      case 'UserEntity':
        return UserEntity().fromJson(json);
      case 'UserData':
        return UserData().fromJson(json);
      case 'UserDataBanner':
        return UserDataBanner().fromJson(json);
      case 'UserDataUserInfo':
        return UserDataUserInfo().fromJson(json);
      case 'PayChannelEntity':
        return PayChannelEntity().fromJson(json);
      case 'PayChannelData':
        return PayChannelData().fromJson(json);
      case 'PayChannelDataPayChannel':
        return PayChannelDataPayChannel().fromJson(json);
    }
    return null;
  }

  //empty list is returned by type
  static _getListFromType(String type) {
    switch (type) {
      case 'UserEntity':
        return List<UserEntity>();
      case 'UserData':
        return List<UserData>();
      case 'UserDataBanner':
        return List<UserDataBanner>();
      case 'UserDataUserInfo':
        return List<UserDataUserInfo>();
      case 'PayChannelEntity':
        return List<PayChannelEntity>();
      case 'PayChannelData':
        return List<PayChannelData>();
      case 'PayChannelDataPayChannel':
        return List<PayChannelDataPayChannel>();
    }
    return null;
  }

  static M fromJsonAsT<M>(json) {
    String type = M.toString();
    if (json is List && type.contains("List<")) {
      String itemType = type.substring(5, type.length - 1);
      List tempList = _getListFromType(itemType);
      json.forEach((itemJson) {
        tempList
            .add(_fromJsonSingle(type.substring(5, type.length - 1), itemJson));
      });
      return tempList as M;
    } else {
      return _fromJsonSingle(M.toString(), json) as M;
    }
  }
}
